#!/bin/bash


set -o pipefail

VERSION="1.0.0"
DATE="2023-12-04"
SCRIPT_NAME=$(basename "$0")

# Verify dependencies
if [ -z "$(command -v jq)" ]; then
  echo "Application jq required to use this tool!"
  exit 1
fi
if [ -z "$(command -v kubectl)" ]; then
  echo "Application kubectl required to use this tool!"
  exit 1
fi

check_secret() {
    local namespace="$1"
    local secret_name="$2"

    kubectl -n "$namespace" get secret "$secret_name" > /dev/null 2>&1
    local secret_exists=$?
    verbose_print "    returned $secret_exists"

    return "$secret_exists"
}

verbose_print() {
  if [ "$VERBOSE" = true ]; then
      echo "$1"
  fi
}

usage() {
  echo "Usage: $SCRIPT_NAME [-n <namespace>] [-s <secret>] [-k <key>] [-h]"
  echo "Decode and display Kubernetes secrets."
  echo "Options:"
  echo "  -k KEY_NAME     Specify a specific key to display (optional)"
  echo "  -n NAMESPACE    Specify namespace (default current context) (optional)"
  echo "  -s SECRET_NAME  Specify the secret name (see Environment Variables for defaults) (optional)"
  echo
  echo "  Utility Options:"
  echo "  -h              Display this menu"
  echo "  -v              Verbose mode"
  echo "  -V              Version information"
  echo
  echo "  Not Yet Implemented Options:"
  echo "  -c KUBECONFIG   Specify a KUBECONFIG to use for kubectl (optional)" 
  echo
  echo "  Environment Variables:"
  echo
  echo "  KUBESECRETS_DEFAULT_SECRET_NAME        if -s is not set, default to this name"
  echo "  KUBESECRETS_NAMESPACE_SECRET_FALLBACK  if -s is not set AND default isn't set or has failed, try using \
a secret named the same as the NAMESPACE"
  exit 1
}

handle_todo() {
  local failed_opt=$1
  echo "Option -$failed_opt has not yet been implemented"
  exit 1
}

version_info() {
  echo "$SCRIPT_NAME Version $VERSION - $DATE"
  exit 0
}

decode_secrets() {
    local namespace="$1"
    local secret_name="$2"
    local key_name="$3"

    while IFS=$'\t' read -r KEY VALUE
    do
        if [ -z "$key_name" ] || [ "$key_name" == "$KEY" ]; then
            DECODED=$(printf "%s" "$VALUE" | base64 --decode)
            printf "%s: %s\n" "${KEY}" "${DECODED}"
        fi
    done < <(kubectl -n "$namespace" get secrets "$secret_name" -o json | jq -r '.data | to_entries[] | "\(.key)\t\(.value)"')
}

# Default values
VERBOSE=false

# Parse command line options
while getopts ":c:hk:n:s:vV" opt; do
  case $opt in
    h)
      usage
      ;;
    k)
      KEY_NAME="$OPTARG"
      ;;
    n)
      NAMESPACE="$OPTARG"
      ;;
    s)
      SECRET_NAME="$OPTARG"
      ;;
    v)
      VERBOSE=true
      ;;
    V)
      version_info
      ;;

    c)
      handle_todo "$opt"
      ;;

    \?)
      echo "Invalid option: -$OPTARG" >&2
      usage
      ;;
  esac
done

if [ -z "$NAMESPACE" ] ; then
    NAMESPACE=$(kubectl config view --minify -o jsonpath='{..namespace}')
fi

#if [ -z "$SECRET_NAME" ] ; then
#    echo "  Secret Name not specified, attempting to auto-match"
#    if [ "${KUBESECRETS_DEFAULT_SECRET_NAME-}" != "" ]; then
#        echo "  Attempting $KUBESECRETS_DEFAULT_SECRET_NAME..."
#        if check_secret_key "$NAMESPACE" "$KUBESECRETS_DEFAULT_SECRET_NAME" "$KEY_NAME"; then
#            SECRET_NAME="$KUBESECRETS_DEFAULT_SECRET_NAME"
#        fi
#    fi
#    if [ -z "$SECRET_NAME" ] && [ "${KUBESECRETS_NAMESPACE_SECRET_FALLBACK-}" = true ]; then
#        echo "  Attempting $NAMESPACE..."
#        if check_secret_key "$NAMESPACE" "$NAMESPACE" "$KEY_NAME"; then
#            SECRET_NAME="$NAMESPACE"
#        fi
#    fi
#    if [ -z "$SECRET_NAME" ]; then
#        echo "   Error: Unable to auto-match secret name. Please try again using -s to specify a secret name"
#        if [ -z "$KUBESECRETS_DEFAULT_SECRET_NAME" ] || [ -z "$KUBESECRETS_NAMESPACE_SECRET_FALLBACK" ]; then
#            echo "   Warning: Set KUBESECRETS_DEFAULT_SECRET_NAME and/or KUBESECRETS_NAMESPACE_SECRET_FALLBACK \
#environment variables to use auto-match"
#        fi
#        exit 1
#    fi
#else
#    # Check if the key exists in the secret
#    if ! check_secret_key "$NAMESPACE" "$SECRET_NAME" "$KEY_NAME"; then
#        echo "Warning: Key $KEY_NAME not found in secret $SECRET_NAME."
#        exit 1
#    fi
#fi

if [ -z "$SECRET_NAME" ]; then
    verbose_print "  Secret Name not specified, attempting to auto-match"
    # If no name provided, run through the known defaults
    if [ "${KUBESECRETS_DEFAULT_SECRET_NAME-}" != "" ]; then
        verbose_print "  Attempting $KUBESECRETS_DEFAULT_SECRET_NAME..."
        if check_secret "$NAMESPACE" "$KUBESECRETS_DEFAULT_SECRET_NAME"; then
            SECRET_NAME="$KUBESECRETS_DEFAULT_SECRET_NAME"
        fi
    fi
    if [ -z "$SECRET_NAME" ] && [ "${KUBESECRETS_NAMESPACE_SECRET_FALLBACK-}" = true ]; then
        verbose_print "  Attempting $NAMESPACE..."
        if check_secret "$NAMESPACE" "$NAMESPACE"; then
            SECRET_NAME="$NAMESPACE"
        fi
    fi
    if [ -z "$SECRET_NAME" ]; then
        echo "   Error: Unable to auto-match secret name. Please try again using -s to specify a secret name"
        if [ -z "$KUBESECRETS_DEFAULT_SECRET_NAME" ] || [ -z "$KUBESECRETS_NAMESPACE_SECRET_FALLBACK" ]; then
            echo "   Warning: Set KUBESECRETS_DEFAULT_SECRET_NAME and/or KUBESECRETS_NAMESPACE_SECRET_FALLBACK \
environment variables to use auto-match"
        fi
        exit 1
    fi
else
    if ! check_secret "$NAMESPACE" "$SECRET_NAME"; then
        echo "   Error: secret $SECRET_NAME does not exist in namespace $NAMESPACE"
    fi
fi

decode_secrets "$NAMESPACE" "$SECRET_NAME" "$KEY_NAME"

