#!/bin/bash

function decode_secrets() {
  PARAM_SECRET_NAME="$1"
  kubectl get secrets "$PARAM_SECRET_NAME" -o json | jq -r '.data | try to_entries[] | "\(.key)\t\(.value)"' |
    while IFS=$'\t' read KEY VALUE
    do
      DECODED=$(printf "%s" "$VALUE" | base64 --decode)
      echo "${KEY}: ${DECODED}"
    done
}

# Verify dependencies
if [ -z $(which jq) ] ; then
  echo "Application jq required to use this tool!"
  exit 1
fi
if [ -z $(which kubectl) ] ; then
  echo "Application kubectl required to use this tool!"
  exit 1
fi

NAMESPACE=$(kubectl config view --minify -o jsonpath='{..namespace}')
DEFAULT_SECRETS=("production-application-secrets" "production-application-secret-files" "$NAMESPACE")

# Fetch secret name from CLI Args
SECRET_NAME="$1"
if [ -z "$SECRET_NAME" ] ; then
  # If no name provided, run through the known defaults
  IFS=$'\n' SECRETS=$(kubectl get secrets --no-headers -o custom-columns=":metadata.name")
  for SECRET_NAME in ${DEFAULT_SECRETS[@]}; do
    for SECRET in ${SECRETS[@]}; do
      if [ "$SECRET" == "$SECRET_NAME" ] ; then
        echo "${SECRET_NAME}:"
        echo "______"
        decode_secrets "$SECRET_NAME"
        echo "______"
      fi
    done
  done

else
  decode_secrets "$SECRET_NAME"
fi
